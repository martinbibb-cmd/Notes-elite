<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Notes-Elite – Boiler Survey (with Auto Arse-Covers)</title>
<style>
  :root{--bg:#0f1115;--fg:#e8eaf0;--muted:#9aa3b2;--tile:#171a21;--accent:#4da3ff;--good:#52d273}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--fg);font:500 16px/1.45 system-ui,Segoe UI,Roboto,Helvetica,Arial}
  .app{display:grid;grid-template-columns:280px 1fr;min-height:100vh}
  .nav{border-right:1px solid #222733;background:#0c0e13;position:sticky;top:0;height:100vh;overflow:auto}
  .nav h1{font-size:18px;margin:12px 16px 4px;color:var(--muted)}
  .nav button{all:unset;display:block;width:100%;padding:14px 16px;border-radius:6px;color:var(--fg);cursor:pointer}
  .nav button:hover{background:#141823}
  .nav .active{background:#141b28;box-shadow:inset 0 0 0 1px #1a2233}
  .main{padding:18px;display:flex;flex-direction:column;gap:16px}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .btn{all:unset;background:#1a2030;border:1px solid #26324a;padding:10px 12px;border-radius:8px;cursor:pointer}
  .btn:hover{background:#21283b}
  .btn.primary{background:#183559;border-color:#1f4880;color:#dbe9ff}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px}
  .tile{background:var(--tile);border:1px solid #22293a;border-radius:12px;padding:14px;display:flex;gap:10px;align-items:flex-start;cursor:pointer;min-height:64px}
  .tile input{margin-top:3px}
  .tile .label{font-weight:600}
  .tile small{display:block;color:var(--muted);margin-top:6px}
  .pill{display:inline-flex;gap:8px;align-items:center;padding:6px 10px;border-radius:999px;background:#131823;border:1px solid #20283a;color:#c6d1e6}
  .section-title{display:flex;justify-content:space-between;align-items:center}
  .kicker{color:#9fb7ff;font-weight:700;text-transform:uppercase;font-size:12px;letter-spacing:.08em}
  .panel{background:#0e121a;border:1px solid #20283a;border-radius:12px;padding:14px}
  .two{display:grid;grid-template-columns:1fr 360px;gap:14px}
  @media (max-width: 980px){.app{grid-template-columns:1fr}.nav{position:relative;height:auto}.two{grid-template-columns:1fr}}
  code,pre{font-family:ui-monospace,Menlo,Consolas,monospace}
  .jsonbox{white-space:pre-wrap;word-break:break-word;background:#0b0e14;border:1px solid #20283a;border-radius:10px;padding:12px}
  .success{color:var(--good)}
</style>
</head>
<body>
<div class="app">
  <aside class="nav" id="nav"></aside>

  <main class="main">
    <div class="section-title">
      <div>
        <div class="kicker" id="kicker">Section</div>
        <h2 id="title" style="margin:.25rem 0 0">Loading…</h2>
      </div>
      <div class="toolbar">
        <button class="btn" onclick="openW3W()">+ what3words</button>
        <button class="btn" onclick="promptManualW3W()">Type 3 words…</button>
        <button class="btn" onclick="geoToW3W()">Use GPS → 3 words</button>
        <button class="btn primary" onclick="exportJSON()">Export JSON</button>
      </div>
    </div>

    <div class="two">
      <section class="panel">
        <div id="tiles" class="grid"></div>
      </section>

      <aside class="panel">
        <div class="kicker">Depot Notes (Live Preview)</div>
        <div id="preview"></div>
        <hr style="border-color:#1c263a;margin:12px 0">
        <div class="kicker">what3words</div>
        <div id="w3wBox">No location added yet.</div>
      </aside>
    </div>

    <section class="panel">
      <div class="kicker">JSON Export (copy box)</div>
      <pre class="jsonbox" id="jsonBox">{}</pre>
    </section>
  </main>
</div>

<script>
/* ------------------------------- STATE --------------------------------- */
const nav = document.getElementById('nav');
const tilesEl = document.getElementById('tiles');
const titleEl = document.getElementById('title');
const kickerEl = document.getElementById('kicker');
const previewEl = document.getElementById('preview');
const jsonBox = document.getElementById('jsonBox');
const w3wBox = document.getElementById('w3wBox');

const state = {
  selections: {},
  w3w: null
};

let sections = [];
let sectionMap = new Map();
let itemIndex = new Map();
let autoNotes = {__always: []};
let w3wConfig = {writeTo: [], mirrorDelivery: false};

/* ------------------------------ INIT LOAD ------------------------------- */
init();

async function init(){
  try{
    const data = await loadSurveyMarkdown('Options.md');
    sections = data.sections;
    sectionMap = new Map(sections.map(sec => [sec.key, sec]));
    itemIndex = data.itemIndex;
    autoNotes = data.autoNotes;
    w3wConfig = data.w3wConfig;

    state.selections = Object.fromEntries(sections.map(sec => [sec.key, new Set()]));

    buildNavigation();
    const firstButton = nav.querySelector('button');
    if(firstButton){
      showSection(sections[0].key, firstButton);
    }else{
      titleEl.textContent = 'No sections found';
      kickerEl.textContent = 'Check Options.md for content.';
    }
  }catch(err){
    console.error('Failed to load survey markdown', err);
    titleEl.textContent = 'Failed to load options';
    kickerEl.textContent = '';
    tilesEl.innerHTML = `<p style="color:#ff7676">Unable to load Options.md (${escapeHtml(err.message ?? 'unknown error')})</p>`;
  }finally{
    updatePreview();
  }
}

/* -------------------------- MARKDOWN PARSING ---------------------------- */
async function loadSurveyMarkdown(url){
  const res = await fetch(url);
  if(!res.ok){
    throw new Error(`${res.status} ${res.statusText}`);
  }
  const text = await res.text();
  return parseSurveyMarkdown(text);
}

function parseSurveyMarkdown(text){
  const lines = text.replace(/\r\n/g, '\n').split('\n');
  const sections = [];
  const w3w = {writeTo: [], mirrorDelivery: false};
  const autoLines = [];

  let currentSection = null;
  let headingContext = [];
  let bulletStack = [];
  let parsingAuto = false;

  for(const rawLine of lines){
    const line = rawLine;
    const trimmed = line.trim();

    if(!parsingAuto && /^#\s*Auto Arse-Covers/i.test(trimmed)){
      parsingAuto = true;
      continue;
    }
    if(parsingAuto){
      autoLines.push(line);
      continue;
    }

    if(/^---$/.test(trimmed)){
      continue;
    }

    if(/^##\s+/.test(line)){
      const title = cleanText(line.replace(/^##\s+/, ''));
      const section = {
        key: `sec${sections.length + 1}`,
        title,
        displayTitle: prettifyTitle(title),
        nodes: [],
        sectionRules: []
      };
      sections.push(section);
      currentSection = section;
      headingContext = [];
      bulletStack = [];
      continue;
    }

    if(!currentSection){
      continue;
    }

    if(/^###\s+/.test(line)){
      const heading = cleanText(line.replace(/^###\s+/, ''));
      headingContext = heading ? [heading] : [];
      bulletStack = [];
      continue;
    }

    if(/^####\s+/.test(line)){
      const heading = cleanText(line.replace(/^####\s+/, ''));
      if(heading){
        headingContext[1] = heading;
      }
      bulletStack = [];
      continue;
    }

    if(!trimmed){
      continue;
    }

    if(trimmed.startsWith('<!--')){
      const ruleMatch = trimmed.match(/<!--\s*rule:\s*([a-zA-Z0-9_]+)\s*=\s*([^>]+?)\s*-->/);
      if(ruleMatch){
        const [, name, rawValue] = ruleMatch;
        const value = /^true$/i.test(rawValue.trim());
        const target = bulletStack.length ? bulletStack[bulletStack.length - 1] : null;
        if(target){
          target.ownRules.push({name, value});
        }else{
          currentSection.sectionRules.push({name, value});
        }
        continue;
      }

      const w3wMatch = trimmed.match(/<!--\s*w3w:([a-zA-Z0-9_]+)\s*=\s*([^>]+?)\s*-->/);
      if(w3wMatch){
        const [, key, raw] = w3wMatch;
        if(key === 'write_to'){
          try{
            const arr = JSON.parse(raw.trim());
            if(Array.isArray(arr)){
              w3w.writeTo = arr;
            }
          }catch(err){
            console.warn('Failed to parse w3w write_to directive', raw, err);
          }
        }else if(key === 'mirror_delivery'){
          w3w.mirrorDelivery = /^true$/i.test(raw.trim());
        }
        continue;
      }
      continue;
    }

    const bulletMatch = line.match(/^(\s*)-\s+(.*)$/);
    if(bulletMatch){
      const indentSpaces = bulletMatch[1].length;
      const level = Math.floor(indentSpaces / 2);
      while(bulletStack.length > level){
        bulletStack.pop();
      }

      const content = bulletMatch[2];
      const isCheckbox = /^\[.?\]/.test(content);
      let text = content;
      if(isCheckbox){
        text = content.replace(/^\[.?\]\s*/, '');
      }
      const cleaned = cleanText(text);
      const parent = bulletStack.length ? bulletStack[bulletStack.length - 1] : null;
      const node = {
        text: cleaned,
        level,
        parent,
        children: [],
        headingContext: headingContext.filter(Boolean).filter(h => !/^Choose one$/i.test(h)),
        ownRules: [],
        selectable: isCheckbox
      };
      if(parent){
        parent.children.push(node);
      }
      currentSection.nodes.push(node);
      bulletStack.push(node);
    }
  }

  const itemIndex = new Map();
  sections.forEach(section => {
    section.displayTitle = section.displayTitle || section.title;
    const baseBucket = determineSectionBucket(section.displayTitle);
    const items = [];

    section.nodes.forEach(node => {
      if(!node.selectable){
        return;
      }

      const ancestors = [];
      let parent = node.parent;
      while(parent){
        if(parent.text){
          ancestors.unshift(parent.text);
        }
        parent = parent.parent;
      }

      const contextParts = [...node.headingContext, ...ancestors];
      const context = contextParts.length ? contextParts.join(' → ') : '';
      const main = node.text;
      const preview = context ? `${context} → ${main}` : main;
      const html = `<div class="label">${escapeHtml(main)}</div>${context ? `<small>${escapeHtml(context)}</small>` : ''}`;

      const ruleMap = new Map(section.sectionRules.map(r => [r.name, r.value]));
      let cursor = node;
      while(cursor){
        cursor.ownRules.forEach(r => ruleMap.set(r.name, r.value));
        cursor = cursor.parent;
      }
      const rules = Array.from(ruleMap.entries()).map(([name, value]) => ({name, value}));

      const bucket = deriveBucket(baseBucket, contextParts);
      const id = `item${itemIndex.size + 1}`;
      const item = {
        id,
        sectionKey: section.key,
        sectionTitle: section.title,
        sectionDisplayTitle: section.displayTitle,
        main,
        context,
        preview,
        html,
        rules,
        bucket
      };

      items.push(item);
      itemIndex.set(id, item);
    });

    section.items = items;
    section.bucketName = baseBucket;
  });

  const autoNotes = parseAutoSection(autoLines);

  return {sections, itemIndex, autoNotes, w3wConfig: w3w};
}

function parseAutoSection(lines){
  const notes = {__always: []};
  let currentKey = null;

  for(const rawLine of lines){
    const line = rawLine.trim();
    if(!line){
      continue;
    }

    const ifMatch = line.match(/^- \*\*If `([^`]+)`\*\*/i);
    if(ifMatch){
      currentKey = ifMatch[1];
      if(!notes[currentKey]){
        notes[currentKey] = [];
      }
      continue;
    }

    const alwaysMatch = line.match(/^- \*\*Always include General\*\*/i);
    if(alwaysMatch){
      currentKey = '__always';
      if(!notes.__always){
        notes.__always = [];
      }
      continue;
    }

    if(line.startsWith('- ') && currentKey){
      const text = cleanText(line.slice(2));
      if(text){
        notes[currentKey].push(text);
      }
    }
  }

  if(!notes.__always){
    notes.__always = [];
  }

  return notes;
}

/* ------------------------------- HELPERS -------------------------------- */
function prettifyTitle(title){
  return title.replace(/^\d+\)\s*/, '').trim();
}

function cleanText(str){
  return str
    .replace(/\*\*(.*?)\*\*/g, '$1')
    .replace(/__(.*?)__/g, '$1')
    .replace(/`([^`]+)`/g, '$1')
    .replace(/\[(.*?)\]\((.*?)\)/g, '$1')
    .replace(/<[^>]+>/g, '')
    .replace(/&nbsp;/gi, ' ')
    .replace(/\s+/g, ' ')
    .trim();
}

function escapeHtml(str){
  return str.replace(/[&<>"']/g, ch => ({'&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'}[ch]));
}

function determineSectionBucket(displayTitle){
  const clean = displayTitle.replace(/\(.*?\)/g, '').trim();
  const lower = clean.toLowerCase();
  if(lower.includes('delivery') && lower.includes('office')){
    return 'Delivery notes';
  }
  if(lower.includes('delivery')){
    return 'Delivery notes';
  }
  if(lower.includes('office')){
    return 'Office notes';
  }
  if(/working at heights/i.test(clean)){
    return 'Working at heights';
  }
  if(/external hazards/i.test(clean)){
    return 'External hazards';
  }
  if(/customer actions/i.test(clean)){
    return 'Customer actions';
  }
  if(/components/i.test(clean) && /assistance/i.test(clean)){
    return 'Components that require assistance';
  }
  if(/restrictions/i.test(clean)){
    return 'Restrictions to work';
  }
  if(/flue/i.test(clean)){
    return 'Flue';
  }
  if(/pipe work/i.test(clean)){
    return 'Pipe work';
  }
  if(/disruption/i.test(clean)){
    return 'Disruption';
  }
  if(/needs/i.test(clean)){
    return 'Needs';
  }
  if(/system/i.test(clean) && /controls/i.test(clean)){
    return 'New boiler and controls';
  }
  if(/universal requirements/i.test(clean)){
    return 'Universal requirements';
  }
  if(/old boiler/i.test(clean)){
    return 'System change planning';
  }
  return clean;
}

function deriveBucket(baseBucket, contextParts){
  if(baseBucket === 'Delivery notes' && contextParts.some(part => /office/i.test(part))){
    return 'Office notes';
  }
  return baseBucket;
}

/* ------------------------------ UI BUILD -------------------------------- */
function buildNavigation(){
  nav.innerHTML = '';
  sections.forEach(section => {
    const btn = document.createElement('button');
    btn.textContent = section.displayTitle;
    btn.onclick = () => showSection(section.key, btn);
    nav.append(btn);
  });
}

function showSection(sectionKey, btn){
  nav.querySelectorAll('button').forEach(b => b.classList.remove('active'));
  if(btn){
    btn.classList.add('active');
  }

  const section = sectionMap.get(sectionKey);
  if(!section){
    return;
  }

  titleEl.textContent = section.displayTitle;
  kickerEl.textContent = 'Select all that apply';
  tilesEl.innerHTML = '';

  section.items.forEach(item => {
    const tile = document.createElement('label');
    tile.className = 'tile';

    const cb = document.createElement('input');
    cb.type = 'checkbox';
    cb.checked = state.selections[section.key]?.has(item.id) ?? false;
    cb.onchange = (event) => {
      const set = state.selections[section.key];
      if(event.target.checked){
        set.add(item.id);
      }else{
        set.delete(item.id);
      }
      updatePreview();
    };

    const text = document.createElement('div');
    text.innerHTML = item.html;

    tile.append(cb, text);
    tilesEl.append(tile);
  });

  updatePreview();
}

/* ----------------------- PREVIEW / MAPPING / EXPORT -------------------- */
function buildDepotBuckets(){
  if(!sections.length){
    return [];
  }

  const bucketMap = new Map();
  const activeRules = {};

  sections.forEach(section => {
    const set = state.selections[section.key];
    if(!set){
      return;
    }
    set.forEach(id => {
      const item = itemIndex.get(id);
      if(!item){
        return;
      }
      if(!bucketMap.has(item.bucket)){
        bucketMap.set(item.bucket, new Set());
      }
      bucketMap.get(item.bucket).add(`• ${item.preview}`);

      item.rules.forEach(rule => {
        if(rule.value){
          activeRules[rule.name] = true;
        }else if(!(rule.name in activeRules)){
          activeRules[rule.name] = false;
        }
      });
    });
  });

  if(state.w3w){
    const line = `• what3words: ${state.w3w}`;
    if(Array.isArray(w3wConfig.writeTo) && w3wConfig.writeTo.length){
      w3wConfig.writeTo.forEach(bucket => {
        if(!bucketMap.has(bucket)){
          bucketMap.set(bucket, new Set());
        }
        bucketMap.get(bucket).add(line);
      });
    }

    if(w3wConfig.mirrorDelivery && bucketMap.has('Delivery notes') && bucketMap.get('Delivery notes').has(line)){
      if(!bucketMap.has('Office notes')){
        bucketMap.set('Office notes', new Set());
      }
      bucketMap.get('Office notes').add(line);
    }
  }

  const autoSet = new Set();
  if(Array.isArray(autoNotes.__always)){
    autoNotes.__always.forEach(note => autoSet.add(`• ${note}`));
  }
  Object.entries(autoNotes).forEach(([rule, notes]) => {
    if(rule === '__always'){
      return;
    }
    if(activeRules[rule] && Array.isArray(notes)){
      notes.forEach(note => autoSet.add(`• ${note}`));
    }
  });
  if(autoSet.size){
    bucketMap.set('Arse-cover notes (auto)', autoSet);
  }

  return [...bucketMap.entries()].map(([bucket, lines]) => ({bucket, lines: [...lines]}));
}

function updatePreview(){
  const entries = buildDepotBuckets();
  if(!entries.length){
    previewEl.innerHTML = '<em>No selections yet.</em>';
  }else{
    previewEl.innerHTML = entries.map(entry => {
      const listItems = entry.lines.map(li => `<li>${li}</li>`).join('');
      return `<p class="pill">${entry.bucket}</p><ul>${listItems}</ul>`;
    }).join('');
  }

  const depotNotesObject = Object.fromEntries(entries.map(entry => [entry.bucket, entry.lines]));
  const exportObj = {
    generated_at: new Date().toISOString(),
    what3words: state.w3w,
    depot_notes: depotNotesObject
  };
  jsonBox.textContent = JSON.stringify(exportObj, null, 2);
}

/* -------------------------- WHAT3WORDS HOOKS ---------------------------- */
function openW3W(){
  const hint = encodeURIComponent(state.w3w ?? '');
  const url = `shortcuts://run-shortcut?name=Add%20what3words&input=text&text=${hint}`;
  window.location.href = url;
}

function promptManualW3W(){
  const input = prompt('Type what3words (e.g. index.home.raft):', state.w3w ?? '');
  if(!input){
    return;
  }
  state.w3w = input.trim();
  w3wBox.innerHTML = `<span class="success">✓</span> ${state.w3w}`;
  updatePreview();
}

async function geoToW3W(){
  if(!navigator.geolocation){
    alert('Geolocation not available');
    return;
  }
  navigator.geolocation.getCurrentPosition(async position => {
    const {latitude: lat, longitude: lng} = position.coords;
    try{
      const url = `https://w3w-proxy.martinbibb.worker.dev/convert-to-3wa?coordinates=${lat},${lng}`;
      const response = await fetch(url);
      if(!response.ok){
        throw new Error('Proxy error');
      }
      const data = await response.json();
      const words = data.words || data.threeWords || data.words3 || data.w3w || null;
      if(!words){
        throw new Error('Unexpected response from proxy');
      }
      state.w3w = words;
      w3wBox.innerHTML = `<span class="success">✓</span> ${state.w3w} <small>(${lat.toFixed(5)}, ${lng.toFixed(5)})</small>`;
      updatePreview();
    }catch(err){
      console.warn(err);
      alert('Couldn’t convert location via proxy. Enter manually.');
      promptManualW3W();
    }
  }, error => alert('Location error: ' + error.message), {enableHighAccuracy: true, timeout: 12000});
}

/* ---------------------------- EXPORT (FILE) ----------------------------- */
function exportJSON(){
  const data = jsonBox.textContent;
  const blob = new Blob([data], {type: 'application/json'});
  const anchor = document.createElement('a');
  anchor.href = URL.createObjectURL(blob);
  anchor.download = `depot-notes_${new Date().toISOString().replace(/[:.]/g, '-')}.json`;
  anchor.click();
  URL.revokeObjectURL(anchor.href);
}
</script>
</body>
</html>
